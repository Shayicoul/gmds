{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GMDS Documentation Last changes We currently change our installation procedure. In particular, we externalize some of gmds depencies. See the developer documentation for more details. Important work is done on the Python API, see the the pygmds module. Our blocking structure is evolving to be more robust and efficient for the blocking procedure. See the blocking module. GMDS in a nuthsell GMDS , for G eneric M esh D ata & S ervices, is a C++ library written to provide mesh data structures and algorithms to developers that intend to design meshing algorithms and build pipelines of those algorithms. The development of this library started a few years ago to provide a generic way of designing data structures representing unstructured 2D and 3D meshes. Such meshes are defined as collections of cells that are topologically connected. Cells can be: - Nodes, or 0-dimensional cells (0-cells) - Edges, or 1-dimensional cells (1-cells) - Faces, or 2-dimensional cells (2-cells) - Regions, or 3-dimensional cells (3-cells) Depending on the meshing algorithm a developer has to write, he must decide which cells are mandatory and which topological connections. Indeed, for an algorithm you may need to store edges and/or faces with the relation from nodes to edges and to faces and vice-versa, while for another you may require regions and the topological relation from faces to regions. GMDS provide flexible mechanisms to handle a huge variety of models and type of cells (triangles, quadrilaterals, tetrahedra, ...). As we are mainly concerned about structured meshes in our team, most of proposed algorithms are dedicated to quadrilateral and hexahedral meshes. A Generic mesh data structure The data structures we provide are based onto the definition of a mesh model, which describes the available cells and connections in the mesh. For instance, in the next example code, a model is defined with flags DIM3|F|E|N|F2N|E2N|N2F. It means that the mesh is a 3D one (DIM3) made of faces (F), edges (E) and nodes (N) and connections from faces to nodes (F2N), edges to nodes (E2N) and nodes to faces (N2F) are explicitly stored. MeshModel model(DIM3|F|E|N|F2N|E2N|N2F); Mesh m(model); // load a file into m for(auto node_id: m->nodes()){ Node n = m.get<Node>(node_id); Point p = n.point(); } gmds provides a framework for developing new algorithms and our current interest is about structured quadrilateral and hexahedral meshing. To generate such meshes, we focus on the following technologies : - Frame Fields . 3 modules are currenly dedicated to the usage of frame fields fo meshing - the frame module provides algorithms for 2D meshing. It relies on the notion of cross fields (see the math component for cross definitions). Output of this module are 2D cross fields defined on an input simplex mesh. - the singGraphBuild module provides algorithm to extract the base complex structure of a 2D frame field - the frame3d module provides algorithms for 3D frame field generation. Unlike the 2D case, we are not able to generate a full block structure but such fields are used to drive hybrid mesh generation and point generation algorithms. - Overlay grids algorithms . - Sheet operations . This module provides sheet operations for quad and hex meshes. A service-based approach In order to build and prototype secure pipeline algorithms, we propose a service module to assemble our algorithms into a verified and dynamically-secured pipeline. We strongly believe that a main drawback of research but also production codes is that they're are written by researchers in mathematics, physics or computer science who focuses on the application \"business\" without taking care of \"software engineering\". This is quite usual and understandable but such a behaviour has 2 main consequences: 1. Codes are not Algorithms for quad and hex meshing GMDS is our ma robust enough because the specification of their input and output are often fuzzy, only known by the main developer; 2. It is difficult to reuse an algorithm written by someone else. The service module is an answer to this issue. Input and output of each service must be totally specified using a constraint system that is dynamically checked at execution time. Users and developers documentation Documentation is under construction. we just start to write it. It is split between: - Users documentation , which is dedicated to people who want to use gmds as a set of libraries but do not expect to contribute to it. - Developers documentation , which is dedicated to developers who would like to create a new gmds module for instance. In particular, we explain the git workflow that we adopted. - Gitub pages are under construction and available here . - The asso Coding Guidelines and Tips GMDS follows strict coding guidelines, please take a look here before submitting your pull requests. We also have a set of general coding tips on how to code a geometry processing research project. Built with MkDocs This documentation uses MkDocs. For full documentation visit mkdocs.org .","title":"Home"},{"location":"#gmds-documentation","text":"","title":"GMDS Documentation"},{"location":"#last-changes","text":"We currently change our installation procedure. In particular, we externalize some of gmds depencies. See the developer documentation for more details. Important work is done on the Python API, see the the pygmds module. Our blocking structure is evolving to be more robust and efficient for the blocking procedure. See the blocking module.","title":"Last changes"},{"location":"#gmds-in-a-nuthsell","text":"GMDS , for G eneric M esh D ata & S ervices, is a C++ library written to provide mesh data structures and algorithms to developers that intend to design meshing algorithms and build pipelines of those algorithms. The development of this library started a few years ago to provide a generic way of designing data structures representing unstructured 2D and 3D meshes. Such meshes are defined as collections of cells that are topologically connected. Cells can be: - Nodes, or 0-dimensional cells (0-cells) - Edges, or 1-dimensional cells (1-cells) - Faces, or 2-dimensional cells (2-cells) - Regions, or 3-dimensional cells (3-cells) Depending on the meshing algorithm a developer has to write, he must decide which cells are mandatory and which topological connections. Indeed, for an algorithm you may need to store edges and/or faces with the relation from nodes to edges and to faces and vice-versa, while for another you may require regions and the topological relation from faces to regions. GMDS provide flexible mechanisms to handle a huge variety of models and type of cells (triangles, quadrilaterals, tetrahedra, ...). As we are mainly concerned about structured meshes in our team, most of proposed algorithms are dedicated to quadrilateral and hexahedral meshes.","title":"GMDS in a nuthsell"},{"location":"#a-generic-mesh-data-structure","text":"The data structures we provide are based onto the definition of a mesh model, which describes the available cells and connections in the mesh. For instance, in the next example code, a model is defined with flags DIM3|F|E|N|F2N|E2N|N2F. It means that the mesh is a 3D one (DIM3) made of faces (F), edges (E) and nodes (N) and connections from faces to nodes (F2N), edges to nodes (E2N) and nodes to faces (N2F) are explicitly stored. MeshModel model(DIM3|F|E|N|F2N|E2N|N2F); Mesh m(model); // load a file into m for(auto node_id: m->nodes()){ Node n = m.get<Node>(node_id); Point p = n.point(); } gmds provides a framework for developing new algorithms and our current interest is about structured quadrilateral and hexahedral meshing. To generate such meshes, we focus on the following technologies : - Frame Fields . 3 modules are currenly dedicated to the usage of frame fields fo meshing - the frame module provides algorithms for 2D meshing. It relies on the notion of cross fields (see the math component for cross definitions). Output of this module are 2D cross fields defined on an input simplex mesh. - the singGraphBuild module provides algorithm to extract the base complex structure of a 2D frame field - the frame3d module provides algorithms for 3D frame field generation. Unlike the 2D case, we are not able to generate a full block structure but such fields are used to drive hybrid mesh generation and point generation algorithms. - Overlay grids algorithms . - Sheet operations . This module provides sheet operations for quad and hex meshes.","title":"A Generic mesh data structure"},{"location":"#a-service-based-approach","text":"In order to build and prototype secure pipeline algorithms, we propose a service module to assemble our algorithms into a verified and dynamically-secured pipeline. We strongly believe that a main drawback of research but also production codes is that they're are written by researchers in mathematics, physics or computer science who focuses on the application \"business\" without taking care of \"software engineering\". This is quite usual and understandable but such a behaviour has 2 main consequences: 1. Codes are not","title":"A service-based approach"},{"location":"#algorithms-for-quad-and-hex-meshing","text":"GMDS is our ma robust enough because the specification of their input and output are often fuzzy, only known by the main developer; 2. It is difficult to reuse an algorithm written by someone else. The service module is an answer to this issue. Input and output of each service must be totally specified using a constraint system that is dynamically checked at execution time.","title":"Algorithms for quad and hex meshing"},{"location":"#users-and-developers-documentation","text":"Documentation is under construction. we just start to write it. It is split between: - Users documentation , which is dedicated to people who want to use gmds as a set of libraries but do not expect to contribute to it. - Developers documentation , which is dedicated to developers who would like to create a new gmds module for instance. In particular, we explain the git workflow that we adopted. - Gitub pages are under construction and available here . - The asso","title":"Users and developers documentation"},{"location":"#coding-guidelines-and-tips","text":"GMDS follows strict coding guidelines, please take a look here before submitting your pull requests. We also have a set of general coding tips on how to code a geometry processing research project.","title":"Coding Guidelines and Tips"},{"location":"#built-with-mkdocs","text":"This documentation uses MkDocs. For full documentation visit mkdocs.org .","title":"Built with MkDocs"},{"location":"dev-guide/developers_doc/","text":"Developer documentation Setting your development environment gmds depends on many external components. In order to develop gmds, they need to be installed properly in order to be used with CMake. On linux systems, and macos, we suggest to use spack for installing your depencies. We use this system for our CI workflows. In a nutshell, spack allows you to install a set of libraries in a specific directory. You can see it as an equivalent of Python environment . In our context, we will simply install the set of dependencies we need and use them in our CMake build system. As an example, let's take a look how to install the basic set of gmds components, plus the blocking component with the Python API and without CGNS dependency. Raw installation of dependencies with spack First of all, we download spack and change its way of installing libraries (second line with the sed command). After that, any library toto installed with spack will be located in absolute_path/spack/opt/spack/toto/ . git clone --depth=1 -b releases/latest https://github.com/spack/spack.git sed -i 's#\"${ARCHITECTURE}/${COMPILERNAME}-${COMPILERVER}/${PACKAGE}-${VERSION}-${HASH}\"#\"${PACKAGE}\"#g' spack/etc/spack/defaults/config.yaml . ./spack/share/spack/setup-env.sh Now, we can install the different packages that are required by gmds . There are many ways of doing it. We use here the most basic one, that consists in successively asking spack to install all the required dependencies. Here: - lcov is used to perform code coverage locally to your computer; - py-pybind11 is mandatory for the python API; - glpk is a linear programming solver that we used in some of our gmds basic components; - googletest is used for our testing infrastructure; - cgal is required for the blocking component. spack external find cmake spack install lcov spack install py-pybind11 spack install glpk spack install googletest spack install cgal spack install --only dependencies gmds+kmds+blocking ^kokkos+openmp ^cgns~mpi Once all those libraries installed, gmds can be compiled with CMake using the following options -DWITH_PYTHON_API=ON -DENABLE_BLOCKING=ON -DWITH_CGNS=OFF -DWITH_TEST=ON -DGLPK_INC=/absolute_path/spack/opt/spack/glpk/include -DGLPK_LIB=/absolute_path/spack/opt/spack/glpk/lib -DCMAKE_PREFIX_PATH=/absolute_path/spack/opt/spack/googletest;/absolute_path/spack/opt/spack/py-pybind11;/absolute_path/spack/opt/spack/cgal;/absolute_path/spack/opt/spack/gmp;/absolute_path/spack/opt/spack/mpfr;/absolute_path/spack/opt/spack/boost Usage of specific spack recipes Instead of manually and individually installing all the gmds dependencies, we can gather gmds requirements into a spack recipe . This recipe will be used by the spack engine to prepare and build the full environment. Our meshing recipes are stored in a github repository that you have to clone and add in the list of spack repositories. git clone --branch gmds_temp --depth=1 https://github.com/LIHPC-Computational-Geometry/spack_recipes_meshing.git spack repo add ./spack_recipes_meshing/meshing_repo spack repo add ./spack_recipes_meshing/supersede_repo Then you can install the gmds dependencies using lines like: spack external find cmake spack install py-pybind11 spack install --only dependencies gmds+blocking Right now, the python binding configuration, as well as the CGNS options, are not managed in the gmds spack recipe. That's why, we separately install pybind11 and the last line will install cgns too. Creation of an optional module Once a component created, we use a github workflow in order to structure the code development. We also intensively use unit tests to valid our codes and also to perform code coverage when we merge developments. The creation of a new GMDS component requires to follow the guideline given below. How to write/update a CMakeLists.txt file for a module Be careful, each time you add a new header file in the inc subdirectory or a source file in the src subdirectory, a reference to this file must be added in the CMakeLists.txt* file. How to create a new module GMDS is structured as a set of libraries, each library being defined in a module. We follow the strict rule of \"one module gives one library\". In order to define a new module, and so library you have to follow the next series of actions. Let us consider that we want to define a new module named xxx At the root directory of gmds , add a directory, named by your module name (always start with a small letter). Let us call it xxx ; At the root directory of gmds , open the file CMakeLists.txt and add the following command in the section entitle OPTIONAL COMPONENTS GMDS_ADD_COMPONENT( XXX # cmake variable xxx # src subdirectory name GMDSXxx # name of the generated library \"description of the component\" # description ON # is activated ON # must be covered ) GMDS_ADD_COMPONENT is a CMake macro for GMDS. - The first parameter of the macro is the CMake variable that will be used for this component. - The source code of the component must be in the subdirectory given as the second parameter. - The third parameter is the name given at the component library when it will be installed. In the project and everywhere in another \"CMakeLists.txt\" file, the library will be accessible via the marco ${LIB_GMDS_XXX}$ - The fourth parameter is a Boolean flag indicating that the component must be built (ON) or not (OFF) - The fifth parameter is also a Boolean flag used to know if the module must be covered by the code coverage procedure that we use when a \"push\"-like command is performed. Get into the xxx subdirectory and create 3 subdirectories named inc , src and tst and a CMakeLists.txt file. In the inc subdirectory create a subdirectory gmds that includes subdirectory xxx* to achieve the following structure xxx/inc/gmds/xxx/** Fill the *CMakeLists.txt\" file as follows: #============================================================================== # LIBRARY DEFINTION (SOURCE FILES) #============================================================================== # Explicity used the name given in this preamble set(GMDS_LIB ${LIB_GMDS_XXX}) set(GMDS_LIB_PREFIX gmds/xxx) set(GMDS_INC inc/gmds/xxx/Class1.h inc/gmds/xxx/Class2.h ) set(GMDS_SRC src/Class1.cpp src/Class2.cpp ) #============================================================================== add_library(${GMDS_LIB} ${GMDS_INC} ${GMDS_SRC}) #============================================================================== # TARGET DEFINITION #============================================================================== include(GNUInstallDirs) #LIBRARY TO INSTALL target_link_libraries(${GMDS_LIB} PUBLIC ${LIB_GMDS_CAD} ${LIB_GMDS_IG}) #============================================================================== # NOTHING TO UPDATE BELOW #============================================================================== target_compile_features(${GMDS_LIB} PUBLIC cxx_std_14) # INCLUDE TO INSTALL target_include_directories(${GMDS_LIB} PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/inc> $<INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include> ) set_target_properties(${GMDS_LIB} PROPERTIES PUBLIC_HEADER \"${GMDS_INC}\") install(TARGETS ${GMDS_LIB} EXPORT GMDS_SUITE PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${GMDS_LIB_PREFIX} LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/gmds ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/gmds) #============================================================================== if(WITH_TEST) # add_subdirectory(tst) endif(WITH_TEST) #============================================================================== This file deserves a few comments: - You must set the two first variable using the name of your component (XXX) and the name of the subdirectory (xxx). - Each time you create a new class, the corresponding header and src files must be added to the lists GMDS_INC and GMDS_SRC respectively. - Note that the inc subidrectory is always structured with two subdirectories, i.e. inc/gmds/xxx/ for getting a homogeneous way of accessing to gmds header files. - The command target_link_libraries(${GMDS_LIB} PUBLIC ....) is very important. It is where you give the dependency of your module to other GDMS module or to external libraries. - The remainder of the CMakefiles.txt should not be edited. It is used to generate libraries and to define the install procedure How to create an executable in a GMDS module A GMDS module is associated to a library. But sometimes, for debug and test reasons, we can generate an executable. Considering the module XXX , you can do it by adding the next lines in the *CMakeLists.txt\" file.","title":"How to develop a gmds module"},{"location":"dev-guide/developers_doc/#developer-documentation","text":"","title":"Developer documentation"},{"location":"dev-guide/developers_doc/#setting-your-development-environment","text":"gmds depends on many external components. In order to develop gmds, they need to be installed properly in order to be used with CMake. On linux systems, and macos, we suggest to use spack for installing your depencies. We use this system for our CI workflows. In a nutshell, spack allows you to install a set of libraries in a specific directory. You can see it as an equivalent of Python environment . In our context, we will simply install the set of dependencies we need and use them in our CMake build system. As an example, let's take a look how to install the basic set of gmds components, plus the blocking component with the Python API and without CGNS dependency.","title":"Setting your development environment"},{"location":"dev-guide/developers_doc/#raw-installation-of-dependencies-with-spack","text":"First of all, we download spack and change its way of installing libraries (second line with the sed command). After that, any library toto installed with spack will be located in absolute_path/spack/opt/spack/toto/ . git clone --depth=1 -b releases/latest https://github.com/spack/spack.git sed -i 's#\"${ARCHITECTURE}/${COMPILERNAME}-${COMPILERVER}/${PACKAGE}-${VERSION}-${HASH}\"#\"${PACKAGE}\"#g' spack/etc/spack/defaults/config.yaml . ./spack/share/spack/setup-env.sh Now, we can install the different packages that are required by gmds . There are many ways of doing it. We use here the most basic one, that consists in successively asking spack to install all the required dependencies. Here: - lcov is used to perform code coverage locally to your computer; - py-pybind11 is mandatory for the python API; - glpk is a linear programming solver that we used in some of our gmds basic components; - googletest is used for our testing infrastructure; - cgal is required for the blocking component. spack external find cmake spack install lcov spack install py-pybind11 spack install glpk spack install googletest spack install cgal spack install --only dependencies gmds+kmds+blocking ^kokkos+openmp ^cgns~mpi Once all those libraries installed, gmds can be compiled with CMake using the following options -DWITH_PYTHON_API=ON -DENABLE_BLOCKING=ON -DWITH_CGNS=OFF -DWITH_TEST=ON -DGLPK_INC=/absolute_path/spack/opt/spack/glpk/include -DGLPK_LIB=/absolute_path/spack/opt/spack/glpk/lib -DCMAKE_PREFIX_PATH=/absolute_path/spack/opt/spack/googletest;/absolute_path/spack/opt/spack/py-pybind11;/absolute_path/spack/opt/spack/cgal;/absolute_path/spack/opt/spack/gmp;/absolute_path/spack/opt/spack/mpfr;/absolute_path/spack/opt/spack/boost","title":"Raw installation of dependencies with spack"},{"location":"dev-guide/developers_doc/#usage-of-specific-spack-recipes","text":"Instead of manually and individually installing all the gmds dependencies, we can gather gmds requirements into a spack recipe . This recipe will be used by the spack engine to prepare and build the full environment. Our meshing recipes are stored in a github repository that you have to clone and add in the list of spack repositories. git clone --branch gmds_temp --depth=1 https://github.com/LIHPC-Computational-Geometry/spack_recipes_meshing.git spack repo add ./spack_recipes_meshing/meshing_repo spack repo add ./spack_recipes_meshing/supersede_repo Then you can install the gmds dependencies using lines like: spack external find cmake spack install py-pybind11 spack install --only dependencies gmds+blocking Right now, the python binding configuration, as well as the CGNS options, are not managed in the gmds spack recipe. That's why, we separately install pybind11 and the last line will install cgns too.","title":"Usage of specific spack recipes"},{"location":"dev-guide/developers_doc/#creation-of-an-optional-module","text":"Once a component created, we use a github workflow in order to structure the code development. We also intensively use unit tests to valid our codes and also to perform code coverage when we merge developments. The creation of a new GMDS component requires to follow the guideline given below.","title":"Creation of an optional module"},{"location":"dev-guide/developers_doc/#how-to-writeupdate-a-cmakeliststxt-file-for-a-module","text":"Be careful, each time you add a new header file in the inc subdirectory or a source file in the src subdirectory, a reference to this file must be added in the CMakeLists.txt* file.","title":"How to write/update a CMakeLists.txt file for a module"},{"location":"dev-guide/developers_doc/#how-to-create-a-new-module","text":"GMDS is structured as a set of libraries, each library being defined in a module. We follow the strict rule of \"one module gives one library\". In order to define a new module, and so library you have to follow the next series of actions. Let us consider that we want to define a new module named xxx At the root directory of gmds , add a directory, named by your module name (always start with a small letter). Let us call it xxx ; At the root directory of gmds , open the file CMakeLists.txt and add the following command in the section entitle OPTIONAL COMPONENTS GMDS_ADD_COMPONENT( XXX # cmake variable xxx # src subdirectory name GMDSXxx # name of the generated library \"description of the component\" # description ON # is activated ON # must be covered ) GMDS_ADD_COMPONENT is a CMake macro for GMDS. - The first parameter of the macro is the CMake variable that will be used for this component. - The source code of the component must be in the subdirectory given as the second parameter. - The third parameter is the name given at the component library when it will be installed. In the project and everywhere in another \"CMakeLists.txt\" file, the library will be accessible via the marco ${LIB_GMDS_XXX}$ - The fourth parameter is a Boolean flag indicating that the component must be built (ON) or not (OFF) - The fifth parameter is also a Boolean flag used to know if the module must be covered by the code coverage procedure that we use when a \"push\"-like command is performed. Get into the xxx subdirectory and create 3 subdirectories named inc , src and tst and a CMakeLists.txt file. In the inc subdirectory create a subdirectory gmds that includes subdirectory xxx* to achieve the following structure xxx/inc/gmds/xxx/** Fill the *CMakeLists.txt\" file as follows: #============================================================================== # LIBRARY DEFINTION (SOURCE FILES) #============================================================================== # Explicity used the name given in this preamble set(GMDS_LIB ${LIB_GMDS_XXX}) set(GMDS_LIB_PREFIX gmds/xxx) set(GMDS_INC inc/gmds/xxx/Class1.h inc/gmds/xxx/Class2.h ) set(GMDS_SRC src/Class1.cpp src/Class2.cpp ) #============================================================================== add_library(${GMDS_LIB} ${GMDS_INC} ${GMDS_SRC}) #============================================================================== # TARGET DEFINITION #============================================================================== include(GNUInstallDirs) #LIBRARY TO INSTALL target_link_libraries(${GMDS_LIB} PUBLIC ${LIB_GMDS_CAD} ${LIB_GMDS_IG}) #============================================================================== # NOTHING TO UPDATE BELOW #============================================================================== target_compile_features(${GMDS_LIB} PUBLIC cxx_std_14) # INCLUDE TO INSTALL target_include_directories(${GMDS_LIB} PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/inc> $<INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include> ) set_target_properties(${GMDS_LIB} PROPERTIES PUBLIC_HEADER \"${GMDS_INC}\") install(TARGETS ${GMDS_LIB} EXPORT GMDS_SUITE PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${GMDS_LIB_PREFIX} LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/gmds ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/gmds) #============================================================================== if(WITH_TEST) # add_subdirectory(tst) endif(WITH_TEST) #============================================================================== This file deserves a few comments: - You must set the two first variable using the name of your component (XXX) and the name of the subdirectory (xxx). - Each time you create a new class, the corresponding header and src files must be added to the lists GMDS_INC and GMDS_SRC respectively. - Note that the inc subidrectory is always structured with two subdirectories, i.e. inc/gmds/xxx/ for getting a homogeneous way of accessing to gmds header files. - The command target_link_libraries(${GMDS_LIB} PUBLIC ....) is very important. It is where you give the dependency of your module to other GDMS module or to external libraries. - The remainder of the CMakefiles.txt should not be edited. It is used to generate libraries and to define the install procedure","title":"How to create a new module"},{"location":"dev-guide/developers_doc/#how-to-create-an-executable-in-a-gmds-module","text":"A GMDS module is associated to a library. But sometimes, for debug and test reasons, we can generate an executable. Considering the module XXX , you can do it by adding the next lines in the *CMakeLists.txt\" file.","title":"How to create an executable in a GMDS module"},{"location":"dev-guide/unit_test/","text":"Test directory structure Every gmds component has a tst directory that contains test suites to perform. All our tests are based on Google test. The classical structure of a test directory is : AFirstTestSuite.h ASeconTestSuite.h CMakeLists.txt main.cpp Process to test a new feature Each time you need to test a new class and methods you want to develop, the process is the following one. 1. Create a class C by declaring it in inc/C.h and provides all the method definitions in src/C.cpp . At this stage, method definition are either empty methods or methods that throw an exception. 2. Create in tst a new class for testing C behaviour. By convention, you will note it CTestSuite.h . You will then addd test method using google test. As an example below, we test some getters ans setters of the math::Point class. Only one test method is given but the test class (here PointClass ) can contain as much as test method you want. TEST and ASSERT_NEAR are macros provided by the Google Test framework. /*----------------------------------------------------------------------------*/ #ifndef GMDS_POINT_TESTSUITE_H #define GMDS_POINT_TESTSUITE_H /*----------------------------------------------------------------------------*/ #include \"gtest/gtest.h\" #include <gmds/math/Point.h> /*----------------------------------------------------------------------------*/ TEST(PointClass, Setter) { gmds::math::Point p(1,2,3); gmds::TCoord z = p.Z(); ASSERT_NEAR(p.X(), 1, 1e-6); ASSERT_NEAR(p.Y(), 2, 1e-6); ASSERT_NEAR(z, 3, 1e-6); } /*----------------------------------------------------------------------------*/ #endif //GMDS_POINT_TESTSUITE_H /*----------------------------------------------------------------------------*/ Once created the file must be added in the CMakeLists.txt to be used in the compilation stage. Get into this file and only modify the list of header/source files used to build the executable test. add_executable(GMDS_MATH_TEST ChartTestSuite.h CrossTestSuite.h Cross2DTestSuite.h MathTestSuite.h PointTestSuite.h QuaternionTestSuite.h OrientationTestSuite.h ... CTestSuite.h ... main_test.cpp) If the directory tst is empty and you are the first one to create a unit test suite for a component. Just copy and paste a CMakeLists.txt file of another component test directory and change the executable name and likely the list of dependencies (in the CMake macro target_link_libraries ). It remains a last step, which is to modify (or create) the main_test.cpp file, which looks like /*----------------------------------------------------------------------------*/ #include <gtest/gtest.h> /*----------------------------------------------------------------------------*/ // Files containing the different test suites to launch #include <ChartTestSuite.h> #include <Cross2DTestSuite.h> #include <CrossTestSuite.h> #include <OrientationTestSuite.h> /*----------------------------------------------------------------------------*/ int main(int argc, char ** argv) { ::testing::InitGoogleTest(&argc, argv); return RUN_ALL_TESTS(); } /*----------------------------------------------------------------------------*/ You need to include the new file you just created in the list of files included at the beginning of this file;","title":"Test-driven development"},{"location":"dev-guide/unit_test/#test-directory-structure","text":"Every gmds component has a tst directory that contains test suites to perform. All our tests are based on Google test. The classical structure of a test directory is : AFirstTestSuite.h ASeconTestSuite.h CMakeLists.txt main.cpp","title":"Test directory structure"},{"location":"dev-guide/unit_test/#process-to-test-a-new-feature","text":"Each time you need to test a new class and methods you want to develop, the process is the following one. 1. Create a class C by declaring it in inc/C.h and provides all the method definitions in src/C.cpp . At this stage, method definition are either empty methods or methods that throw an exception. 2. Create in tst a new class for testing C behaviour. By convention, you will note it CTestSuite.h . You will then addd test method using google test. As an example below, we test some getters ans setters of the math::Point class. Only one test method is given but the test class (here PointClass ) can contain as much as test method you want. TEST and ASSERT_NEAR are macros provided by the Google Test framework. /*----------------------------------------------------------------------------*/ #ifndef GMDS_POINT_TESTSUITE_H #define GMDS_POINT_TESTSUITE_H /*----------------------------------------------------------------------------*/ #include \"gtest/gtest.h\" #include <gmds/math/Point.h> /*----------------------------------------------------------------------------*/ TEST(PointClass, Setter) { gmds::math::Point p(1,2,3); gmds::TCoord z = p.Z(); ASSERT_NEAR(p.X(), 1, 1e-6); ASSERT_NEAR(p.Y(), 2, 1e-6); ASSERT_NEAR(z, 3, 1e-6); } /*----------------------------------------------------------------------------*/ #endif //GMDS_POINT_TESTSUITE_H /*----------------------------------------------------------------------------*/ Once created the file must be added in the CMakeLists.txt to be used in the compilation stage. Get into this file and only modify the list of header/source files used to build the executable test. add_executable(GMDS_MATH_TEST ChartTestSuite.h CrossTestSuite.h Cross2DTestSuite.h MathTestSuite.h PointTestSuite.h QuaternionTestSuite.h OrientationTestSuite.h ... CTestSuite.h ... main_test.cpp) If the directory tst is empty and you are the first one to create a unit test suite for a component. Just copy and paste a CMakeLists.txt file of another component test directory and change the executable name and likely the list of dependencies (in the CMake macro target_link_libraries ). It remains a last step, which is to modify (or create) the main_test.cpp file, which looks like /*----------------------------------------------------------------------------*/ #include <gtest/gtest.h> /*----------------------------------------------------------------------------*/ // Files containing the different test suites to launch #include <ChartTestSuite.h> #include <Cross2DTestSuite.h> #include <CrossTestSuite.h> #include <OrientationTestSuite.h> /*----------------------------------------------------------------------------*/ int main(int argc, char ** argv) { ::testing::InitGoogleTest(&argc, argv); return RUN_ALL_TESTS(); } /*----------------------------------------------------------------------------*/ You need to include the new file you just created in the list of files included at the beginning of this file;","title":"Process to test a new feature"},{"location":"user-guide/blocking/","text":"Blocking module This module provides a data structure for a blocking representation. It relies on the n -G-map model and we specifically use the 3-G-Map implementation provided by CGAL library (see https://doc.cgal.org/latest/Generalized_map/index.html). The development of this module is in progress. The final purpose is to provide a robust and reliable curved block structure for hex blocking mesh representation. Compilation and installation This module is built using the global CMakeLists.txt of gmds . An extra option ( WITH_CGNS ) is provided to allow CGNS export. It requires then to install the adequate CGNS library. This procedure must be described in details and the spack recipes must be updated. Main concepts The blocking structure is described in the class CurvedBlocking . It relies on the 3-G-map model and provide several blocking queries and gives access to the underlying 3-G-map. The CurvedBlockingClassifier provides the first prototype to classify a block structure onto a geometrical model. Blocking classification All blocking structures are classified. It means that we need to build a blocking structure from a geometrical model. Nodes, edges and faces are classified on geometrical entities. In order to automatically classify cells, we use two parameters: - a maximal distance MD for projecting a node. If the distance to any geometrical cell is greater than MD , then the node is not moved and classified. - A snapping distance SD that is used during a correction stage. After projecting a node on a curve or a surface, we check if this node could not be snapped onto a geometrical point with a distance lower to SD . Remark: This two parameters are use-case specific and should be automatically computed in the future. Geometrical and topological operations It is possible to move a node with the method CurvedBlocking::move_node . This methods takes classification into account: - A node classified onto a geometrical point cannot move; - A node classified onto a geometrical curve will be moved to the expected location then projected onto the curve; - The same behavior occurs for nodes classified on geometrical surfaces. Two operations are available to remove a block ( CurvedBlocking::remove_block ), or split a series of blocks along an edge ( CurvedBlocking::cut_sheet ). In the second case, the obtained blocks remain glued each to others.","title":"Blocking"},{"location":"user-guide/blocking/#blocking-module","text":"This module provides a data structure for a blocking representation. It relies on the n -G-map model and we specifically use the 3-G-Map implementation provided by CGAL library (see https://doc.cgal.org/latest/Generalized_map/index.html). The development of this module is in progress. The final purpose is to provide a robust and reliable curved block structure for hex blocking mesh representation.","title":"Blocking module"},{"location":"user-guide/blocking/#compilation-and-installation","text":"This module is built using the global CMakeLists.txt of gmds . An extra option ( WITH_CGNS ) is provided to allow CGNS export. It requires then to install the adequate CGNS library. This procedure must be described in details and the spack recipes must be updated.","title":"Compilation and installation"},{"location":"user-guide/blocking/#main-concepts","text":"The blocking structure is described in the class CurvedBlocking . It relies on the 3-G-map model and provide several blocking queries and gives access to the underlying 3-G-map. The CurvedBlockingClassifier provides the first prototype to classify a block structure onto a geometrical model.","title":"Main concepts"},{"location":"user-guide/blocking/#blocking-classification","text":"All blocking structures are classified. It means that we need to build a blocking structure from a geometrical model. Nodes, edges and faces are classified on geometrical entities. In order to automatically classify cells, we use two parameters: - a maximal distance MD for projecting a node. If the distance to any geometrical cell is greater than MD , then the node is not moved and classified. - A snapping distance SD that is used during a correction stage. After projecting a node on a curve or a surface, we check if this node could not be snapped onto a geometrical point with a distance lower to SD . Remark: This two parameters are use-case specific and should be automatically computed in the future.","title":"Blocking classification"},{"location":"user-guide/blocking/#geometrical-and-topological-operations","text":"It is possible to move a node with the method CurvedBlocking::move_node . This methods takes classification into account: - A node classified onto a geometrical point cannot move; - A node classified onto a geometrical curve will be moved to the expected location then projected onto the curve; - The same behavior occurs for nodes classified on geometrical surfaces. Two operations are available to remove a block ( CurvedBlocking::remove_block ), or split a series of blocks along an edge ( CurvedBlocking::cut_sheet ). In the second case, the obtained blocks remain glued each to others.","title":"Geometrical and topological operations"},{"location":"user-guide/cad/","text":"CAD module This module provides cad interface representation for meshing algorithms.","title":"cad "},{"location":"user-guide/cad/#cad-module","text":"This module provides cad interface representation for meshing algorithms.","title":"CAD module"},{"location":"user-guide/cadfac/","text":"CADFAC module This module provides a faceted implementation of the cad interface representation for meshing algorithms.","title":"cadfac "},{"location":"user-guide/cadfac/#cadfac-module","text":"This module provides a faceted implementation of the cad interface representation for meshing algorithms.","title":"CADFAC module"},{"location":"user-guide/elg3d/","text":"Elgmorphing module This module provides algoritmes to morph a mesh","title":"Elg3D"},{"location":"user-guide/elg3d/#elgmorphing-module","text":"This module provides algoritmes to morph a mesh","title":"Elgmorphing module"},{"location":"user-guide/frame/","text":"Frame module","title":"Frame"},{"location":"user-guide/frame/#frame-module","text":"","title":"Frame module"},{"location":"user-guide/frame3d/","text":"Frame3d module","title":"Frame3d"},{"location":"user-guide/frame3d/#frame3d-module","text":"","title":"Frame3d module"},{"location":"user-guide/geodhoneycomb/","text":"GeodHoneyComb module This module provides algorithsm to generate hexahedral meshes for spherical shapes using a pattern based on honeycombs. The usage is depicted by the unit tests given in unit test files (see geodHoneyComb/tst/GeodHoneyCombTestSuite.h for examples). In the following code snippet, we use the class GeodHexMesher to generate a sphere with 3 layers of of cells. The sphere is centered at origin and is radius values 1. We use a uniform discretization for all layers including the central one which contains pyramidal cells in the center. //creation of the meshing algorithm GeodHexMesher ghm; ghm.setCenter(math::Point(0,0,0)); ghm.setRadius(1); //layers are created with a uniform discretization for all of them math::DiscretizationScheme1DUniform d(math::Point(0,0,0), math::Point(1,0,0), 10); auto layer0 = std::make_pair(0., &d); //inner radius being at 0 means we will have a whole sphere auto layer1 = std::make_pair(0.5, &d); auto layer2 = std::make_pair(0.8,&d); auto layer3 = std::make_pair(0.9,&d); std::map<double, math::DiscretizationScheme1D*> layers; layers.insert(layer1); layers.insert(layer2); layers.insert(layer3); layers.insert(layer0); ghm.setLayerData(layers); // execution of the algorithm GeodHexMesher::OpResult res = ghm.execute(); //if the algorithm succeeded, we can access to the produced mesh if(res == GeodHexMesher::GEOD_SUCCESS) std::unique_ptr<Mesh> m = ghm.getMesh(); We get the following resulting mesh with one color per layer.","title":"GeodHoneyComb"},{"location":"user-guide/geodhoneycomb/#geodhoneycomb-module","text":"This module provides algorithsm to generate hexahedral meshes for spherical shapes using a pattern based on honeycombs. The usage is depicted by the unit tests given in unit test files (see geodHoneyComb/tst/GeodHoneyCombTestSuite.h for examples). In the following code snippet, we use the class GeodHexMesher to generate a sphere with 3 layers of of cells. The sphere is centered at origin and is radius values 1. We use a uniform discretization for all layers including the central one which contains pyramidal cells in the center. //creation of the meshing algorithm GeodHexMesher ghm; ghm.setCenter(math::Point(0,0,0)); ghm.setRadius(1); //layers are created with a uniform discretization for all of them math::DiscretizationScheme1DUniform d(math::Point(0,0,0), math::Point(1,0,0), 10); auto layer0 = std::make_pair(0., &d); //inner radius being at 0 means we will have a whole sphere auto layer1 = std::make_pair(0.5, &d); auto layer2 = std::make_pair(0.8,&d); auto layer3 = std::make_pair(0.9,&d); std::map<double, math::DiscretizationScheme1D*> layers; layers.insert(layer1); layers.insert(layer2); layers.insert(layer3); layers.insert(layer0); ghm.setLayerData(layers); // execution of the algorithm GeodHexMesher::OpResult res = ghm.execute(); //if the algorithm succeeded, we can access to the produced mesh if(res == GeodHexMesher::GEOD_SUCCESS) std::unique_ptr<Mesh> m = ghm.getMesh(); We get the following resulting mesh with one color per layer.","title":"GeodHoneyComb module"},{"location":"user-guide/hybridmeshadapt/","text":"HybridMeshAdapt module This module proposes an algorithm to adapt a tetrahedral mesh into an hybrid one using frame fiels and metrics. To achieve a sufficient level of performances, a mesh data structure dedicated to simplicial meshes is used in this component instead of those proposed by the ig and kmds modules. Stage 1 The first executable to use is main_METRIC_FF_PointGeneration : The frontal process is subdividide in 3 step The node generation on the curve, the surface and the volume. The function nodesSpreading is used to spread the node on the surface and then on the volume. The result of this algorithm is a mesh containing the node and the related hexaedron. * metricXYZ_functors is a vector of function containing the metric informations * frameXYZ_functors is a vector of function containing the frame informations (if the function return a nul size vector, the frame field of the mesh is used.) Once The two vector have been specified the constructor MetricFFPointgeneration p(&simplexMesh, name_final_mesh, interpolation_factor) is called, interpolation_factor is the value of the interpolation between the frame and the metric orientation. The frontal process will generate node in the direction of the frame field when interpolation_factor tend to 1. If interpolation_factor tend to 0 the node will follow the directions of the metric directions, (see the function MetricFFPointgeneration::metricInterpolationWithDistorsion(const Eigen::Matrix3d & metric, const Eigen::Matrix3d & frameField)). Stage 2 Once the previous process is done, we call main_HEX_GENERATION with the initial mesh and the result mesh of the main_METRIC_FF_PointGeneration. * First, we perform a Delaunay node insertion, then the node that has not been inserted are inserted using only the simplex containing the current node (l:131-247) * Second, we remove the initial node of the mesh, this step contribute to build the shell of the hexaedron. (l:267-329) * Third, we build the remaining edge between the inserted node (in order to build the shell of the future hexaedron). (l:332-368) * To finish we force the faces of the futur hexaedrons. If the 6 faces exist the hexaedron is built, and the tetraedron forming the hex are marked in order to not be built in the final mesh (l:378-454) Stage 3 The last step will build the hexaedron from the remaining tetradron, the executable main_TET2HEX is called to perform this.","title":"HybridMeshAdapt"},{"location":"user-guide/hybridmeshadapt/#hybridmeshadapt-module","text":"This module proposes an algorithm to adapt a tetrahedral mesh into an hybrid one using frame fiels and metrics. To achieve a sufficient level of performances, a mesh data structure dedicated to simplicial meshes is used in this component instead of those proposed by the ig and kmds modules.","title":"HybridMeshAdapt module"},{"location":"user-guide/hybridmeshadapt/#stage-1","text":"The first executable to use is main_METRIC_FF_PointGeneration : The frontal process is subdividide in 3 step The node generation on the curve, the surface and the volume. The function nodesSpreading is used to spread the node on the surface and then on the volume. The result of this algorithm is a mesh containing the node and the related hexaedron. * metricXYZ_functors is a vector of function containing the metric informations * frameXYZ_functors is a vector of function containing the frame informations (if the function return a nul size vector, the frame field of the mesh is used.) Once The two vector have been specified the constructor MetricFFPointgeneration p(&simplexMesh, name_final_mesh, interpolation_factor) is called, interpolation_factor is the value of the interpolation between the frame and the metric orientation. The frontal process will generate node in the direction of the frame field when interpolation_factor tend to 1. If interpolation_factor tend to 0 the node will follow the directions of the metric directions, (see the function MetricFFPointgeneration::metricInterpolationWithDistorsion(const Eigen::Matrix3d & metric, const Eigen::Matrix3d & frameField)).","title":"Stage 1"},{"location":"user-guide/hybridmeshadapt/#stage-2","text":"Once the previous process is done, we call main_HEX_GENERATION with the initial mesh and the result mesh of the main_METRIC_FF_PointGeneration. * First, we perform a Delaunay node insertion, then the node that has not been inserted are inserted using only the simplex containing the current node (l:131-247) * Second, we remove the initial node of the mesh, this step contribute to build the shell of the hexaedron. (l:267-329) * Third, we build the remaining edge between the inserted node (in order to build the shell of the future hexaedron). (l:332-368) * To finish we force the faces of the futur hexaedrons. If the 6 faces exist the hexaedron is built, and the tetraedron forming the hex are marked in order to not be built in the final mesh (l:378-454)","title":"Stage 2"},{"location":"user-guide/hybridmeshadapt/#stage-3","text":"The last step will build the hexaedron from the remaining tetradron, the executable main_TET2HEX is called to perform this.","title":"Stage 3"},{"location":"user-guide/ig/","text":"IG module IG , for incidence graph, is the main and legacy mesh data structure provided in gmds . The ig module provides basic data structure for handling meshes based on an \" Incident Graph \" representation (which explains why it is called ig ). Traditionally a graph G=(V,A) is made of vertices and arcs that connect vertices. For giving a model to represent mesh data structures, we use such a graph model, where vertices are the dimensions of cells explicitly stored in the data structure. In other words, vertices are denoted: 1. R for regions or 3-dimensional cells (for short 3-cells), 2. F for faces or 2-cells, 3. E for edges or 1-cells, 4. N for nodes or 0-cells. Connections, ie. graph arcs, are cell connections and are written X2Y with X and Y that are R , F , E or N . For instance F2N means that we store the connection from faces to nodes, while N2R indicates that we have to store the connection from nodes to regions. A MeshModel object can be built on this graph structure and given to a Mesh object to initialise it. MeshModel model(DIM3|F|E|N|F2N|E2N|N2F); Mesh m(model); Block-structures meshes In order to handle block structures meshes, we complete the IG representation with a \"quasi-structured\" or \"block-structured\" view built on the traditional IG model (see the class Mesh ) The blocking2D structure is a full unstructured mesh made of hex blocks, quad faces, edges and nodes. Block, faces and edges only exist at the macro level, or block level. Nodes are block corners but also inner-block nodes. Each node knows it is a corner-block (block level) or an inner-node using the node on-node variable called \"embedding\". An embedding is a Cell::Data that corresponds to the block entity the node is embedded in. It is made of a dim and an id. It can be on a corner-block(0), face-block(2), edge-block (1) and inner-block(3). Each block as a grid structure. It must be so possible to use bracket notation [i+,j-1] to acces to a neighbor nodes. This type of traversal should be possible almost everywhere and allows the user to traverse several blocks in a row. The only issue is when you meet singular corners (ie with valence not equal to 4).","title":"ig"},{"location":"user-guide/ig/#ig-module","text":"IG , for incidence graph, is the main and legacy mesh data structure provided in gmds . The ig module provides basic data structure for handling meshes based on an \" Incident Graph \" representation (which explains why it is called ig ). Traditionally a graph G=(V,A) is made of vertices and arcs that connect vertices. For giving a model to represent mesh data structures, we use such a graph model, where vertices are the dimensions of cells explicitly stored in the data structure. In other words, vertices are denoted: 1. R for regions or 3-dimensional cells (for short 3-cells), 2. F for faces or 2-cells, 3. E for edges or 1-cells, 4. N for nodes or 0-cells. Connections, ie. graph arcs, are cell connections and are written X2Y with X and Y that are R , F , E or N . For instance F2N means that we store the connection from faces to nodes, while N2R indicates that we have to store the connection from nodes to regions. A MeshModel object can be built on this graph structure and given to a Mesh object to initialise it. MeshModel model(DIM3|F|E|N|F2N|E2N|N2F); Mesh m(model);","title":"IG module"},{"location":"user-guide/ig/#block-structures-meshes","text":"In order to handle block structures meshes, we complete the IG representation with a \"quasi-structured\" or \"block-structured\" view built on the traditional IG model (see the class Mesh ) The blocking2D structure is a full unstructured mesh made of hex blocks, quad faces, edges and nodes. Block, faces and edges only exist at the macro level, or block level. Nodes are block corners but also inner-block nodes. Each node knows it is a corner-block (block level) or an inner-node using the node on-node variable called \"embedding\". An embedding is a Cell::Data that corresponds to the block entity the node is embedded in. It is made of a dim and an id. It can be on a corner-block(0), face-block(2), edge-block (1) and inner-block(3). Each block as a grid structure. It must be so possible to use bracket notation [i+,j-1] to acces to a neighbor nodes. This type of traversal should be possible almost everywhere and allows the user to traverse several blocks in a row. The only issue is when you meet singular corners (ie with valence not equal to 4).","title":"Block-structures meshes"},{"location":"user-guide/igalgo/","text":"IGAlgo module This module provides some basic algorithms for the incidence graph ( ig ) data structure: Most important algorithms are relative to retrieving and building some boundary informations: boundaryOperator, boundaryExtractor. The GridBuilder class provides algoriths to build 2D and 3D structured grids for unit testing purposes mainly. The THexBuilder create a hexahedral mesh by splitting each tet of an input tetrahedral mesh. The MeshQualityCompute go through all the mesh cells and assign variables depending on a set of selected quality criteria","title":"igalgo "},{"location":"user-guide/igalgo/#igalgo-module","text":"This module provides some basic algorithms for the incidence graph ( ig ) data structure: Most important algorithms are relative to retrieving and building some boundary informations: boundaryOperator, boundaryExtractor. The GridBuilder class provides algoriths to build 2D and 3D structured grids for unit testing purposes mainly. The THexBuilder create a hexahedral mesh by splitting each tet of an input tetrahedral mesh. The MeshQualityCompute go through all the mesh cells and assign variables depending on a set of selected quality criteria","title":"IGAlgo module"},{"location":"user-guide/io/","text":"IO module This module propose mechanisms that allows us to import/export the mesh data structure. This mechanism is not optimized for performances.","title":"io "},{"location":"user-guide/io/#io-module","text":"This module propose mechanisms that allows us to import/export the mesh data structure. This mechanism is not optimized for performances.","title":"IO module"},{"location":"user-guide/kmds/","text":"KMDS module In order to write concurrent meshing algorithms that could benefit from manycore architectures, we derived the incidence graph using the Kokkos library.","title":"kmds"},{"location":"user-guide/kmds/#kmds-module","text":"In order to write concurrent meshing algorithms that could benefit from manycore architectures, we derived the incidence graph using the Kokkos library.","title":"KMDS module"},{"location":"user-guide/math/","text":"Math module This modules gather usual mathematics objects and concepts we use and work with for writing our meshing algorithms.","title":"math "},{"location":"user-guide/math/#math-module","text":"This modules gather usual mathematics objects and concepts we use and work with for writing our meshing algorithms.","title":"Math module"},{"location":"user-guide/padding/","text":"Padding module This module simply contains some padding algorithms. Origin of this work wast to understand and reproduce the work proposed in Selective Padding for Polycube-Based Hexahedral Meshing","title":"padding"},{"location":"user-guide/padding/#padding-module","text":"This module simply contains some padding algorithms. Origin of this work wast to understand and reproduce the work proposed in Selective Padding for Polycube-Based Hexahedral Meshing","title":"Padding module"},{"location":"user-guide/polyblock/","text":"Polyblock module Polycube-maps-based approaches are one of the promising technology that can be used to generate full hex mesh. This module gather the works we've done on this subject.","title":"polyblock"},{"location":"user-guide/polyblock/#polyblock-module","text":"Polycube-maps-based approaches are one of the promising technology that can be used to generate full hex mesh. This module gather the works we've done on this subject.","title":"Polyblock module"},{"location":"user-guide/quality/","text":"Quality module This module gathers quality measure for mesh cells. Proposed quality measure are based on the choice done in the Verdict Geometric Quality Library : - Stimpson, C. J., Ernst, C. D., Knupp, P., P\u00e9bay, P. P., & Thompson, D. (2007). The Verdict library reference manual. Sandia National Laboratories Technical Report, 9. (see https://digital.library.unt.edu/ark:/67531/metadc880826/)","title":"quality "},{"location":"user-guide/quality/#quality-module","text":"This module gathers quality measure for mesh cells. Proposed quality measure are based on the choice done in the Verdict Geometric Quality Library : - Stimpson, C. J., Ernst, C. D., Knupp, P., P\u00e9bay, P. P., & Thompson, D. (2007). The Verdict library reference manual. Sandia National Laboratories Technical Report, 9. (see https://digital.library.unt.edu/ark:/67531/metadc880826/)","title":"Quality module"},{"location":"user-guide/sheet/","text":"Sheet module description In this module, we provide the usual operations that can be safely performed on quad or hex mesh. By safely, we means that the mesh remains a full quad, respectively hex mesh after performing a sheet operation. We provide the 3 basic operations, which are: - Sheet selection . Giving 2 nodes, or an edge, it returns the set of cells that belongs to the corresponding sheet. - Sheet collapse . Giving 2 nodes, or an edge, it removes the corresponding sheet from the mesh. - Sheet pillow . Giving a path of edges or a convex set of cells, it inserts a sheet inside the mesh. Requirements Sheet collapse and pillow are operations that modify the mesh. They are quite easy to implement if you only consider the mesh structure but taking geometric classification makes it more tricky to handle. Geometric classification requires to handle a few special cases where faces (in 3D) and edges (in 2D) are required along the mesh boundary. It means that we restrict our implementation to mesh where: - in 2D, boundary edges must be defined in the mesh and connection E2N at least. We do not use the N2E connectivity because it enforces all the mesh nodes to store an indirection to a potential list of adjacent edges. - in 23D, boundary faces and edges must be defined in the mesh and connections F2N and E2N at least","title":"sheet"},{"location":"user-guide/sheet/#sheet-module-description","text":"In this module, we provide the usual operations that can be safely performed on quad or hex mesh. By safely, we means that the mesh remains a full quad, respectively hex mesh after performing a sheet operation. We provide the 3 basic operations, which are: - Sheet selection . Giving 2 nodes, or an edge, it returns the set of cells that belongs to the corresponding sheet. - Sheet collapse . Giving 2 nodes, or an edge, it removes the corresponding sheet from the mesh. - Sheet pillow . Giving a path of edges or a convex set of cells, it inserts a sheet inside the mesh.","title":"Sheet module description"},{"location":"user-guide/sheet/#requirements","text":"Sheet collapse and pillow are operations that modify the mesh. They are quite easy to implement if you only consider the mesh structure but taking geometric classification makes it more tricky to handle. Geometric classification requires to handle a few special cases where faces (in 3D) and edges (in 2D) are required along the mesh boundary. It means that we restrict our implementation to mesh where: - in 2D, boundary edges must be defined in the mesh and connection E2N at least. We do not use the N2E connectivity because it enforces all the mesh nodes to store an indirection to a potential list of adjacent edges. - in 23D, boundary faces and edges must be defined in the mesh and connections F2N and E2N at least","title":"Requirements"},{"location":"user-guide/singgraphbuild/","text":"SingGraphBuild module Once a 2D frame field generated, the purpose of the current module is to extract the topological structure fo this frame, i.e. a singularity graph .","title":"SingGraphBuild"},{"location":"user-guide/singgraphbuild/#singgraphbuild-module","text":"Once a 2D frame field generated, the purpose of the current module is to extract the topological structure fo this frame, i.e. a singularity graph .","title":"SingGraphBuild module"},{"location":"user-guide/smoothy/","text":"Smoothy module The aim of this module is to gather some smoothing algorithms. Mesh smoothing algorithms consist in moving mesh nodes without changing mesh topology. We classify smoothing algorithms in two categories: 1. Those that are aware of the geometric classification. They are the less academic ones, but those used in practice. Most of the time they provide functions to smooth nodes on curves, surfaces and inside the volumes. 2. The other ones that smooth all the nodes excepted a bunch of ones that are locked to their positions. They derive from academic papers that deal with such low constraints. Elliptic smoothing The elliptic smoother provides an implementation of the ACM TOG paper Foldover-free maps in 50 lines of code (https://dl.acm.org/doi/abs/10.1145/3450626.3459847). This algoriths allows to smooth a 2D mesh with some nodes that are locked. Example of usages are given in the unit tests.","title":"smoothy"},{"location":"user-guide/smoothy/#smoothy-module","text":"The aim of this module is to gather some smoothing algorithms. Mesh smoothing algorithms consist in moving mesh nodes without changing mesh topology. We classify smoothing algorithms in two categories: 1. Those that are aware of the geometric classification. They are the less academic ones, but those used in practice. Most of the time they provide functions to smooth nodes on curves, surfaces and inside the volumes. 2. The other ones that smooth all the nodes excepted a bunch of ones that are locked to their positions. They derive from academic papers that deal with such low constraints.","title":"Smoothy module"},{"location":"user-guide/smoothy/#elliptic-smoothing","text":"The elliptic smoother provides an implementation of the ACM TOG paper Foldover-free maps in 50 lines of code (https://dl.acm.org/doi/abs/10.1145/3450626.3459847). This algoriths allows to smooth a 2D mesh with some nodes that are locked. Example of usages are given in the unit tests.","title":"Elliptic smoothing"},{"location":"user-guide/users_doc/","text":"GMDS is a set of C++ libraries that can be used to develop meshing algorithms. It requires features of C++14. The build system is based on CMAKE (https://cmake.org) and unit tests are performed using google tests and google benchmarks. In order to perform some linear algebra operations, we rely onto the Eigen library (http://eigen.tuxfamily.org/index.php?title=Main_Page) that provides us matrices, vectors, numerical solvers, and related algorithms. How to compile, install and link against GMDS GMDS build system is CMake. In order to build GMDS, the direct way consists in the following stages Cloning the git repository Extracting GMDS from the gitub repository by cloning it (best option if you want to contribute afterward) or copying it. Let us assume that it is extracted in /home/gmds by cloning the github repository. cd /home/ git clone https://github.com/LIHPC-Computational-Geometry/gmds.git Build directory for CMake purpose In the /home/$ directory, we create a directory where the project will be built. Let us name it build*. We will then get into this subdirectory to prepare the project to be built using CMake. cd /home/ mkdir build cd build cmake ../gmds/ Compilation toolchain Depending on the options you provide to the cmake command line, you will get different way of building it. If you chose to create a Makefile, you will then have to build and (optionally) to install it make -j4 make install Example of toy code that uses gmds In the source directory there is a small example of how to link against GMDS in another program cd docs/example cmake -DCMAKE_PREFIX_PATH=<path_to_gmds_install_dir> . make ./examplegmds GMDS Project structure GMDS project is split into a set of \" modules \", which are connected each to others. Each module is structured as follows: One subdirectory inc , which contains all the headers files of the module; One subdirectory src , which contains all the source files of the module; One subdirectory tst , which contains a set of unit tests written using google test. The aim of this tst subdirectory is both to (1) dynamically ensure the right and expected behaviour of the module and (2) provide some usage examples for other developers. A file named CMakeLists.txt used by CMAKE to build the module. GMDS modules are of two kinds : core ones and optional ones Core modules Core modules gather generic data structures, math classes, utils, basic algorithms and some Read and Write interfaces to be implemented. We have: cad : contains all the data structure and main query operations required for writing meshing algorithms. math : mathematical simple concepts that are implemented and reused in many algorithms. io : read and write classes with an interface definition to be implemented for new mesh data structure you would like to read and write. ig : serial generic mesh data structure based on an incidence-graph representation. Optional modules Optional modules can be activated using the cmake option ENABLE_XXX where XXX is the module name. For instance for building the FRAME module, you have to add the option -DENABLE_FRAME=true: cmake ../gmds/ -DENABLE_FRAME=true Available modules are : - frame - frame3d - kmds : concurrent thread-based mesh data structure. \"k\" means \"Kokkos\" the underlying framework we used for managing concurrency. - Elg3D - hybridMeshAdapt - singGraphBuild - ... The lists of all the available optional modules can be seen in the root CMakeLists.txt file or using the ccmake command instead of the cmake command.","title":"How to use gmds"},{"location":"user-guide/users_doc/#how-to-compile-install-and-link-against-gmds","text":"GMDS build system is CMake. In order to build GMDS, the direct way consists in the following stages","title":"How to compile, install and link against GMDS"},{"location":"user-guide/users_doc/#cloning-the-git-repository","text":"Extracting GMDS from the gitub repository by cloning it (best option if you want to contribute afterward) or copying it. Let us assume that it is extracted in /home/gmds by cloning the github repository. cd /home/ git clone https://github.com/LIHPC-Computational-Geometry/gmds.git","title":"Cloning the git repository"},{"location":"user-guide/users_doc/#build-directory-for-cmake-purpose","text":"In the /home/$ directory, we create a directory where the project will be built. Let us name it build*. We will then get into this subdirectory to prepare the project to be built using CMake. cd /home/ mkdir build cd build cmake ../gmds/","title":"Build directory for CMake purpose"},{"location":"user-guide/users_doc/#compilation-toolchain","text":"Depending on the options you provide to the cmake command line, you will get different way of building it. If you chose to create a Makefile, you will then have to build and (optionally) to install it make -j4 make install","title":"Compilation toolchain"},{"location":"user-guide/users_doc/#example-of-toy-code-that-uses-gmds","text":"In the source directory there is a small example of how to link against GMDS in another program cd docs/example cmake -DCMAKE_PREFIX_PATH=<path_to_gmds_install_dir> . make ./examplegmds","title":"Example of toy code that uses gmds"},{"location":"user-guide/users_doc/#gmds-project-structure","text":"GMDS project is split into a set of \" modules \", which are connected each to others. Each module is structured as follows: One subdirectory inc , which contains all the headers files of the module; One subdirectory src , which contains all the source files of the module; One subdirectory tst , which contains a set of unit tests written using google test. The aim of this tst subdirectory is both to (1) dynamically ensure the right and expected behaviour of the module and (2) provide some usage examples for other developers. A file named CMakeLists.txt used by CMAKE to build the module. GMDS modules are of two kinds : core ones and optional ones","title":"GMDS Project structure"},{"location":"user-guide/users_doc/#core-modules","text":"Core modules gather generic data structures, math classes, utils, basic algorithms and some Read and Write interfaces to be implemented. We have: cad : contains all the data structure and main query operations required for writing meshing algorithms. math : mathematical simple concepts that are implemented and reused in many algorithms. io : read and write classes with an interface definition to be implemented for new mesh data structure you would like to read and write. ig : serial generic mesh data structure based on an incidence-graph representation.","title":"Core modules"},{"location":"user-guide/users_doc/#optional-modules","text":"Optional modules can be activated using the cmake option ENABLE_XXX where XXX is the module name. For instance for building the FRAME module, you have to add the option -DENABLE_FRAME=true: cmake ../gmds/ -DENABLE_FRAME=true Available modules are : - frame - frame3d - kmds : concurrent thread-based mesh data structure. \"k\" means \"Kokkos\" the underlying framework we used for managing concurrency. - Elg3D - hybridMeshAdapt - singGraphBuild - ... The lists of all the available optional modules can be seen in the root CMakeLists.txt file or using the ccmake command instead of the cmake command.","title":"Optional modules"},{"location":"user-guide/utils/","text":"Utils module This module gathers utilitary classes that are used in all the gmds components.","title":"utils"},{"location":"user-guide/utils/#utils-module","text":"This module gathers utilitary classes that are used in all the gmds components.","title":"Utils module"}]}